##不可靠的时钟

时钟和时间是重要的。应用通过多种方式依赖时钟：

1. 请求是否超时？
2. 该服务的99%的响应时间是多少？
3. 过去的五分钟里该服务平均每秒能响应多少查询？
4. 用户花了多长时间在站点？
5. 该文章何时发布的？
6. 具体什么时间催单邮件该被发送？
7. 缓存何时过期？
8. 日志中的错误信息时间戳是什么？

问题1-4度量的是时间段（比如请求到来-回应返回的时间差），问题5-8描述的是时间点（时间发生的特定日期，时间）。

在分布式系统中，时间是一件棘手的事务，因为通信不是即时的：通过网络从一台机器传递到另一台机器的消息需要花费一些时间。由于网络延迟的存在，我们不知道接受者接收消息的时间比发送时晚多少。这个现象有时使得确认涉及多台机器的事件发生顺序变得困难。

此外，网络中的每台机器都有自己的时钟，这通常是石英晶体震荡器这种硬件设备。这些设备的精度不是很高，所以每台机器都有自己的时间，可能相对于其他机器是或快或慢的。可以在某种程度上同步时钟：最常用的机制是NTP服务，它可以根据一组服务器上报的时间来调整计算机时钟。服务器轮流通过比如GPS接收器这种更精确的时钟源获取时间。

###单调时钟与日期时钟

现代计算机至少有两种时钟：日期时钟和单调时钟，尽管它们都是用来度量时间，但是需要要知道，这两种时钟是为了不同的目的设计的。

####日期时钟

日期时钟符合你的直观期望：获取具体的日期和时间（也称为挂钟时间）。例如，类Linux操作系统中的`clock_gettime(CLOCK_REAL_TIME)`和Java中的`System.currentTimeMillis()`返回的是自UTC时间 1970年1月1日0点的秒数（或者毫秒数）PS:忽略闰秒。一些系统也已其他时间点作为参考。

日期时钟通常通过NTP服务来同步，这意味着一台计算机上的时间戳与另一台计算机上的相同。然而，如同下一节描述的一样，日期时钟也有不同的可能性。特别地，如果本地时钟距离NTP服务器太远，则可能会被强制跳转到上一个时间点。这些跳跃以及经常忽略闰秒的事实，使得日期时钟不适合度量时间段。

从历史角度，日期时钟有过很粗糙的分辨率，比如老的windows系统上，时钟以10ms的步长前进。当然在最新的系统中，这已经不是问题了。

####单调时钟

单调时钟非常适合用于度量时间段，比如超时或者服务的响应时间：Linux系统的`clock_gettime(CLOCK_MONOTONIC)`和Java的`System.nanoTime()`都是获取单调时钟。名字来源于总是向前移动的事实，而日期时钟可能会由于NTP等导致往回的跳变。

你可以在某个时间点检查单调时钟的值，然后执行一些操作，稍后再次检查单调时钟的值，差值就是时间段。要注意的是，单调时钟的绝对值是没有意义的：它可能是计算机启动以来的纳秒数或者类似的什么值。特别注意的是，比较两台计算机的单调时钟更加没有意义。

在具有多个CPU的计算机上，每个CPU可能有一个有别于其他CPU的单独的计时器。操作系统会尝试补偿CPU之间的差异，并为应用线程提供一个单调的时钟值，即使它们在不同的CPU之间调度。当然，更聪明的做法是有所保留地相信单调时钟。

如果NTP检测到计算机本地的时钟运行频率的快慢与NTP服务不同，会调整单调时钟向前移动的频率（被称为`slewing the clock`）。默认情况下，NTP允许加快或者降低频率最多0.05%，但是NTP不会使得单调时钟向回跳跃。单调时钟的频率通常很高，在大多数系统中可以度量毫秒或者更短的时间段。

在分布式系统中，使用单调时钟来度量时间段是优秀的，因为它不假定不同节点时钟之间存在同步，并且对于微小的度量误差不敏感。

### 时钟同步和准确性

单调时钟不需要同步，但是日期时钟必须根据NTP服务器或者其他外部时钟源同步自身时钟。不幸的是，我们同步时间的结果不总是能得到期望的那样，因为硬件时钟或者NTP服务器可能出现问题，下面举几个例子：

- 计算机中的石英钟不总是很准确的：它会漂移。时钟漂移取决于计算机机器温度。Google假设其服务器时钟漂移为200ppm(pars per million，百万分之一)，相当于每30s有6ms的时钟差异，或者每天17s。时钟漂移限制了你能得到的时钟精度，即使看起来一切正常。
- 如果计算机的时钟跟NTP服务器差异巨大，可能就会拒绝同步，或者直接重置。应用在重置前后得到的时间可能会有大幅向前或者向后的跳变。
- 如果一个节点偶然被NTP服务隔离，错误配置好长一段时间没有被发现。证据表明这种事情真实发生。
- NTP同步依赖与网络延迟稳定，在拥塞导致的延迟不稳定的网络中NTP的准确性不是很好。一个实验表明，一秒内的偶然延迟尖峰会导致最小35ms的差错。根据配置，较大的网络延迟可以使NTP客户端放弃同步
- 有些NTP服务器运行错误或者配置错误，报告的时间少了几个小时。NTP客户端非常强大，因为它们查询多个服务器并且忽略异常值。尽管如此，有时从网络上未知者发来的时间正确性还是需要担忧。
- 闰秒导致的一分钟有59秒或者61秒，这在没有考虑闰秒的系统中会造成时间系统混乱时序。事实表明，闰秒造成过很多大型系统的崩溃，说明时钟的错误假设很容易潜伏在系统中。最好处理闰秒的方式是使NTP服务器逐步慢慢地在一天的时间内修复这个时间误差（被称为`smearing`），尽管真实的NTP服务行为会在修正过程有所不同。
- 虚拟机中，硬件时钟是虚拟化的，这为需要精确计时的应用带来了额外的挑战。当一个CPU内核在多个虚拟机之间共享时，每个虚拟机会在另一个虚拟机运行时暂停数十毫秒。从应用程序的角度来看就是时钟突然向前跳变。
- 如果将软件运行在你不能完全控制的设备上（比如手机或者嵌入式设备），你可能根本不能信任设备的硬件时钟。有些用户会特意错误地设置本地的硬件日期和时间，比如规避游戏中的时间限制。结果时钟可以被设置为过去或者未来的某个时间。

如果投入大量资源，你是可以获取足够准确性的时钟的。比如，针对金融机构的欧洲法规草案MiFID II要求所有的高频交易基金将其时钟同步在UTC的100毫秒以内，以帮助调试市场异常来帮助进行市场操控。

高级别的精确时钟可以通过GPS接收器，PTP和仔细的部署和监控获得。然而这需要大量的精力和专业的只是，并且可以采用多种方式进行时钟同步。如果你的NTP服务错误配置，或者NTP流量被拦截，由于漂移导致的时钟错误会迅速扩大。

### 对同步时钟的依赖

时钟的问题在于，尽管它们看起来简单易用，但是可能有令人意外的陷阱：

### 处理停滞

让我们考虑另一个在分布式系统中使用危险时钟的示例。假设有一个每个分区只有一个领导者的数据库，只有领导者被允许执行写操作，节点如何知道它仍然是领导者（没有被其它节点声明为死亡状态），并且可以安全地接收写入请求？

一种选择是使领导者从其他节点获取租约，这类似一个具有超时的锁。任意时间，只有一个节点可以持有未到期的租约，这样它就知道自己是领导者。为了保持租约，领导节点必须不断续期。如果领导节点续期失败，另一个节点就会接管租约。